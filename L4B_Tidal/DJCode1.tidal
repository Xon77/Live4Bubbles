d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n (run 77)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "0 1"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "0 1 2"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "0 1 2 3"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "0 1 2 3 4"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "0 1 2 3 10 10"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "0 1 2 7 8 9 14 3 2 1 3 10 10"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n (choose [0,2,3]) -- -- Répétera l'aléatoire en fonction du chiffre de d1 - Random by Cycle ?
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n (cycleChoose [0,2,3]) -- only picks once per cycle -- Identique
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ fast "^d1" $ sound "^1Fol" # n "^1Buf" |+ n (choose [0,2,3]) -- Utilisation de fast pour avoir un aléatoire constant - Possibilité de jouer sur la répétition en modifiant d1
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 77) -- Aléatoire complet
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ fast "^d1" $ sound "^1Fol" # n (irand 77) -- Aléatoire complet Rapide
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n (wchoose [(0,0.5),(2,0.35),(3,0.15)]) -- Choose with weight
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 2 $ struct "<[t ~ ~ ~]!15 t(<1 2>,32) [t ~ ~ ~]!15 [t t? t? t?] [t ~ ~ ~]!15 [[t t?] t? t? t?]>*[^d1]" $ dud1 $ fast "^d1" $ sound "^1Fol" # n "^1Buf" |+ n (wchoose [(0,0.8),(2,0.15),(3,0.05)]) -- Choose with weight 2
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slow 8 $ struct "[t t? t? t?]*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" |+ n "6 2 3 5 0 8 7 87 2 23 7 78 3 5 6 2"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ chop "<[16 64 32]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "<4 8 12>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ dud1 $ sound "^1Fol" # n (run 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ fast 2 $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ fast 4 $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ fast 8 $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ striate "^d1" $ dud1 $ sound "^1Fol" # n (irand 200) -- ???
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slice "^d1" "[<0*8 0*2> 3*4 2 4] [4 .. 7]*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slice "^d1" "7 6 5 4 3 2 1 0" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slice "^d1" "7 6 5 4 3 2 1 0" $ dud1 $ sound "^1Fol" # n (run 200) -- New à partir de là
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[t ~ t/16 ~]" $ fast "[^d1]" $ dud1 $ sound "^1Fol" -- different "^d1" ?
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[t ~]*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" -- # n 0
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ echoWith 4 (1/("^d1")) (|* speed "0.9 1.1 0.7 0.8") $ struct "[t ~]*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" -- # n 0
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[~ t]*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" -- # n 0
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[t ~]*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[~ t]*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[~ ~ t ~ ~ t ~ ~]*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf" -- # n 0
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "[~ ~ t ~ ~ t ~ ~]*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!7 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!3 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t*8 t*4] t*[^d1]>" $ dud1 $ sound "^1Fol" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("6 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("16 10 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("8 10 9 9 7"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("8 10 9 9 7"+"^1Buf") # distort "<0 0.03 0.05 0.1>"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("8 10 9 9 7 8 14 18 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("8 10 9 9 7 8 14 18 8"+"^1Buf") # legato "3" -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("8 20 8 14 6 7 8 7 18 6"+"^1Buf") # legato "3" -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("<8 20 8 14 6 7 8 7 18 6>"+"^1Buf") # legato "3" -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("<8 20 8 14 6 7 8 7 18 6 66>"+"^1Buf") # legato "3" -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("<8 20 8 14 6 7 8 7 18 6 6>"+"^1Buf") # legato "6" -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("<8 20 8 14 6 7 8 7 18 6 6>"+"^1Buf") # legato "6" # lpf (range 60 5000 $ perlin2With (cosine*2) (sine*2)) -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("<16 10 8 14>"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 10)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 16))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n (run (irand 10))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n (run (irand 200))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 100)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t ~ t ~]>*[^d1]" $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 10)) -- (n (run 10) ~> "^1Buf") -- n (run 10)+"^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t t t t]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 18) # legato "7" # distort "<0 0.3 0.2 0.1>" # lpf (range 60 5000 $ perlin2With (cosine*2) (sine*2)) -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t t t t]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 18) # legato "2" # distort "<0 0.3 0.2 0.1>" # lpf (range 60 5000 $ perlin2With (cosine*2) (sine*2)) -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t t t t]>*[^d1]" $ dud1 $ sound "^1Fol" # distort "<0 0.3 0.2 0.1>" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t t t t]>*[^d1]" $ dud1 $ sound "^1Fol" # crush "12 8 12 16" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ struct "<[t ~ ~ ~]!15 [t t t t]>*[^d1]" $ dud1 $ sound "^1Fol" # freeze "0.1 0.2 0.4" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid "<3 5>" "[8 16]/4" $ dud1 $ sound "^1Fol" # n "^1Buf"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 2 5 $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 2))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 4 $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 3))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 5 $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 3))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 7 $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 3))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 8 $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 3))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 4 7 $ dud1 $ sound "^1Fol" # n ("^1Buf" |+ (run 4))
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 4 9 $ dud1 $ sound "^1Fol" # n ("1 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 4 11 $ dud1 $ sound "^1Fol" # n ("4 5 6 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 6 $ dud1 $ sound "^1Fol" # n ("6 7 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 7 $ dud1 $ sound "^1Fol" # n ("7 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 8 $ dud1 $ sound "^1Fol" # n ("6 10 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 9 $ dud1 $ sound "^1Fol" # n ("6 7 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 11 $ dud1 $ sound "^1Fol" # n ("0 2 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 12 $ dud1 $ sound "^1Fol" # n ("0 2 1 7 0 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 16 $ dud1 $ sound "^1Fol" # n ("6 2 0 3 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 7 8 $ dud1 $ sound "^1Fol" # n ("6 2 4 8"+"^1Buf")
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 8 $ dud1 $ sound "^1Fol" # n "^1Buf" # legato 100 -- legato & dud en conflit
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 4 $ dud1 $ sound "^1Fol" # n (run 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 5 $ dud1 $ sound "^1Fol" # n (run 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 3 8 $ dud1 $ sound "^1Fol" # n (run 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ fast "^d1" $ slow 3 $ euclid 5 8 $ dud1 $ sound "^1Fol" # n (run 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ chop "<[16 64 32]>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "<4 8 12>*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ dud1 $ sound "^1Fol" # n (run 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ jux rev $ chop "^d1" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ striate "^d1" $ dud1 $ sound "^1Fol" # n (irand 200) -- ???
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slice "^d1" "[<0*8 0*2> 3*4 2 4] [4 .. 7]*[^d1]" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slice "^d1" "7 6 5 4 3 2 1 0" $ dud1 $ sound "^1Fol" # n (irand 200)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ slice "^d1" "7 6 5 4 3 2 1 0" $ dud1 $ sound "^1Fol" # n (run 200)



d1 silence
xfadeIn 1 4 silence -- perform a crossfade transition to silence in 4 cycles
clutchIn 1 4 silence -- clutch degrades the current pattern while undegrading the next -- better on a longer number of cycles 8 ?
interpolateIn 1 4 silence -- Morph control values between patterns in a given number of cycles -- The number of cycles has no effect with silence -- stops immediately -- Other way to stop nicer than Mute -- equivalent to silence ?

-- Other ways to stop a pattern which is too long ?

histpan 1 4 silence -- This will pan the last four patterns on the d1 channel from left to right, the most recent on the left -- Weird panning effect ?

hush -- stops everything or Ctrl + Shift + h



-- Tests sans structure ryhtmique, juste vitesse du "tempo"
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ sound "[^1Fol]*[^d1]" # n "^1Buf" -- |+ n (run 200)

-- Mask to integrate in functions u to play with timing ?
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "1 0" $ sound "[^1Fol]*[^d1]" # n "^1Buf" -- |+ n (run 20)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "1 0 0 0" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (run 20)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "1 0 0 0 1 0 0 0" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (run 20)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "1 0 0 1 1 0 1 0" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (run 20)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 1 1 0 1 0]/2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (run 20)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 1 1 0 1 0]*8" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (run 20)
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 1 1 0 1 0]*8" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (irand 6)

-- Mask and Markov chains -- Tempo sur le sound
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 0 1 0 1 0]*2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (fmap ([0, 1, 2, 3]!!) (markovPat 16 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))

-- Tempo sur le sound & duration of markovPat -- Coodinates the tempo with randomness of markov
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 0 1 0 1 0]*2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (fmap ([0, 1, 2, 3]!!) (markovPat "[^d1]" 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))

d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 0 0 0 1 0]*2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (fmap ([0, 1, 2, 3]!!) (markovPat "[^d1]" 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))

d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 1 0 0 1 0 1]*2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (fmap ([0, 1, 2, 3]!!) (markovPat "[^d1]" 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))

d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 0 0 1 0 1]*2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (fmap ([0, 1, 2, 3]!!) (markovPat "[^d1]" 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))

-- Adding of run on n
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 1 0 0 1 0 1]*2" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (run 100) |+ n (fmap ([0, 1, 2, 3]!!) (markovPat "[^d1]" 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))

-- Tempo sur le sound & duration of markovPat & Mask -- very agressive if too much 1 in masks
d1 $ u1d1 $ u2d1 $ f1d1 $ f2d1 $ dud1 $ mask "[1 0 0 0 1 0 1 0]*[^d1]" $ sound "[^1Fol]*[^d1]" # n "^1Buf" |+ n (fmap ([0, 1, 2, 3]!!) (markovPat "[^d1]" 0 [ [ 0.1, 1.1, 0.9, 0.1 ], [ 0.9, 0.1, 1.1, 1.1 ], [ 0.5, 0.5, 0.05, 1 ], [ 0.5, 0.5, 0.75, 0.25 ] ] ))



 -- n (run 20 |+ 120)



d1 $ gain "1~~1.~~~1.~~1~.~" # s "808"
d1 $ gain "1~~1.~~~1.~~1~.~" $ s "808"
-- maybe "0@3 0@4 0@3 0@6" # s "808" (unless you actually care about the gaps)



-- every 2 (degradeBy 0.4) -> très cool (à faire en preset)
-- every 2 (degradeBy 0.15)
-- degradeBy 0.4 -> la dégradation est la même sur chaque piste ? Comment avoir un aléatoire différent pour chaque piste ?



-- Euclidean Rhythms

-- E(2,5)=[x . x . .] is a thirteenth century Persian rhythm called Khafif-e-ramal [34]. It is also the metric pattern of the second movement of Tchaikovsky’s Symphony No. 6 [17]. When it is started on the second onset ([x . . x .]) it is the metric pattern of Dave Brubeck’s Take Five as well as Mars from The Planets by Gustav Holst [17].

-- E(3,4)=[x . x x] is the archetypal pattern of the Cumbia from Colombia [20], as well as a Calypso rhythm from Trinidad [13]. It is also a thirteenth century Persian rhythm called Khalif-e-saghil [34], as well as the trochoid choreic rhythmic pattern of ancient Greece [21].

-- E(3,5)=[x . x . x], when started on the second onset, is another thirteenth century Persian rhythm by the name of Khafif-e-ramal [34], as well as a Rumanian folk-dance rhythm [25].

-- E(3,7)=[x . x . x . .] is a Ruchenitza rhythm used in a Bulgarian folk-dance [24]. It is also the metric pattern of Pink Floyd’s Money [17].

-- E(3,8)=[x . . x . . x .] is the Cuban tresillo pattern discussed in the preceding [15].

-- E(4,7)=[x . x . x . x] is another Ruchenitza Bulgarian folk-dance rhythm [24].

-- E(4,9) = [x . x . x . x . .] is the Aksak rhythm of Turkey [6]. It is also the metric pattern used by Dave Brubeck in his piece Rondo a la Turk [17].

-- E(4,11) = [x . . x . . x . . x .] is the metric pattern used by Frank Zappa in his piece titled Outside Now [17].

-- E(5,6)=[x . x x x x] yields the York-Samai pattern, a popular Arab rhythm, when started on the second onset [30].

-- E(5,7)=[x . x x . x x] is the Nawakhat pattern, another popular Arab rhythm [30].

-- E(5,8)=[x . x x . x x .] is the Cuban cinquillo pattern discussed in the preceding [15]. When it is started on the second onset it is also the Spanish Tango [13] and a thirteenth century Persian rhythm, the Al-saghilal-sani [34].

-- E(5,9)=[x . x . x . x . x] is a popular Arab rhythm called Agsag-Samai [30]. When started on the second onset, it is a drum pattern used by the Venda in South Africa [26], as well as a Rumanian folk-dance rhythm [25].

-- E(5,11)=[x . x . x . x . x . .] is the metric pattern used by Moussorgsky in Pictures at an Exhibition [17].

-- E(5,12) = [x . . x . x . . x . x .] is the Venda clapping pattern of a South African children’s song [24].

-- E(5,16) = [x . . x . . x . . x . . x . . . .] is the Bossa-Nova rhythm necklace of Brazil. The actual BossaNova rhythm usually starts on the third onset as follows: [x . . x . . x . . . x . . x . .] [31]. However, there are other starting places as well, as for example [x . . x . . x . . x . . . x . .] [3].

-- E(7,8) = [x . x x x x x x] is a typical rhythm played on the Bendir (frame drum), and used in the accompaniment of songs of the Tuareg people of Libya [30].
